使用类定义自己的数据类型，本章主要关注数据抽象，如何将对象的具体实现和对象所能执行的操作分离开

### **类**
**数据抽象**
* 接口：用户所能执行的操作
* 实现：类的数据成员、私有函数、负责接口实现的函数体、
**封装**
实现了类的接口和实现的分离，用户只能使用接口而无法访问实现
***
### **定义抽象数据类型**
抽象数据类型就是只允许用户访问其接口而不能访问其他数据成员的类型，定义抽象数据类型需要定义一些操作供用户使用，从而封装它的数据成员                                                                                                                                                                               
注：执行加法和IO的函数定义为普通函数

**成员函数**
声明在类的内部，定义可以在内部也可以在外部。（定义在类内部的是隐式inline函数）
**非成员函数**
定义和声明都在类外部

**this**
成员函数通过隐式参数this来访问调用它的对象，因此在成员函数内部可以直接访问该对象的成员，而无需通过成员访问运算符，因为隐含了（this->)
this是一个常量指针，不允许改变this中保存的地址

**const成员函数**
作用是修改隐式this指针的类型
默认情况下，this是指向非常量版本的常量指针，这样就不能把this绑定到常量对象上，使用const将this声明成指向常量的指针，成为常量成员函数
```
struct S{
	string isbn() const {return bookNo;}//紧跟参数列表之后
};
```

**在类外部定义成员函数**
也需指名const；需写成 类名：：成员函数名 的形式，表示位于类的作用域
***
### **构造函数**
初始化类的数据成员，在类的对象被创建时调用。
构造函数名字与类名相同，没有返回类型，不能被声明为const。
**默认构造函数**
类可以包含多个构造函数（函数重载），如果没有定义则调用默认构造函数，默认构造函数无任何实参。
```
Sales_data()=default;//默认构造函数
Sales_data(string s,int n):bookNo(s),value(n){}//另一个构造函数，构造函数初始值列表
```

### **访问控制与封装**
使用访问说明符加强类的封装性
**public**
之后的成员可以在整个程序内访问，存放构造函数和接口
**private**
之后的成员可以被类的成员函数访问，但不能被外部访问，存放数据成员和作为实现部分的函数

### **class vs struct**
都可以定义类，但默认访问权限不同。（所以力扣使用的是struct。。）
class 默认private，默认私有继承；struct默认public，默认公有继承

### **友元**
类可以允许其他类或函数访问它的非公有成员，方法是令他们成为友元，增加一条以friend开头的函数声明语句即可。
友元只能出现在类的内部，但位置不限
**令成员函数成为友元**
1.定义友元类A，并声明成员函数，但不能定义它
2.定义类B，包括对A中成员函数的友元声明
3.定义A的成员函数
**类和非成员函数的声明**
不一定在友元声明前，但要在使用前

### **令成员作为内联函数**
在内部声明和外部定义处加inline均可，最好在外部定义处加

### **可变成员函数**
在变量的声明前加入mutable关键词，该数据成员可以被修改，即使是在一个const成员函数内

### **类的名字查找**
**类内部成员函数中的名字**
1.编译成员的声明
2.直到类全部可见后才编译函数体
因此，函数体可以使用类中定义的任何名字，包括在该函数后定义的名字
**类成员声明的名字**
1.在类内部该声明出现前查找
2.如果没有找到，在类的外层作用域查找
声明中使用的名字，包括返回类型和参数列表使用的名字，必须在使用前可见

### **构造函数**
**初始值列表**
大部分情况与赋值相同，但如果是const或引用，必须执行初始化，不能使用赋值
初始化顺序与在类中的定义顺序一致，与构造函数初始化列表中出现的顺序无关
**委托构造函数**
使用它所属类的其他构造函数执行zi'j
**默认构造函数**
参数列表为空或者提供默认实参的构造函数
**转换构造函数**
通过只接受一个实参的构造函数，定义了转换为此类类型的隐式转换机制，隐式转换只允许一步转换
**explicit**
将构造函数声明为explicit可以抑制隐式转换，且只能以直接初始化的形式使用

### **聚合类**
* 所有成员都是public
* 没有任何构造函数
* 没有类内初始值
* 没有基类，也没有virtual函数

### **类的静态成员**
与类本身相关，而不是与类的对象相关，对象中不包含与静态数据成员有关的数据，
加上static，该关键字只出现在类内部的声明语句
**静态数据成员**
只能在外部定义，一个静态数据成员只能定义一次。内存中只有一份
**静态函数**
没有this指针，只能处理静态数据成员
两种调用方式：
* 通过类名
* 和普通成员函数一样

