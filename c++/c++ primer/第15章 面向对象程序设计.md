### **OOP**
面向对象程序设计：封装、多态、继承
**封装**
数据抽象，将类的接口与实现分离
**继承**
定义相似的类型并对其相似关系建模，基类->派生类
友元不能继承。
**多态**
动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

### **定义基类和派生类**
派生类必须通过使用类派生列表，明确指出它是从哪些基类继承而来的
基类必须区分两种成员函数：
1.基类希望派生类进行覆盖的函数    虚函数
2.基类希望派生类直接继承而不要改变的函数
```
class classP:public classJ{
}
```
需要覆盖的成员函数必须在派生类重新声明，在后面添加override标明该函数将会覆盖一个虚函数
**虚函数**
对于某些函数，基类希望它的派生类各自定义适合自身的版本。virtual
根据绑定的对象不同，执行不同类的版本，动态绑定
**派生类构造函数**
使用基类的构造函数初始化它的基类部分
**静态成员**
只存在唯一实例
**防止继承的发生**
后面添加final



### **派生类到基类的类型转换**
```
classJ J;//基类对象
classP P;//派生类对象
classJ *t = &J;//基类指针指向基类对象
t = &P;//基类指针指向派生类对象中继承基类的部分
classJ &r = P;//基类r绑定到派生类对象中继承基类的部分
```
我们可以将派生类对象当成基类对象使用，也能将基类对象的指针或引用绑定到派生类对象的基类部分上。

### **纯虚函数**
在声明处=0
无需定义
### **抽象基类**
含有纯虚函数的类是抽象基类。
抽象基类负责定义接口，后续子类可以覆盖接口，不能直接创建一个抽象基类的对象

### **访问控制**
protected：与私有成员类似，类外部不可访问；与公有成员类似，对派生类和友元是可以访问的。派生类只能通过派生类对象访问基类的受保护成员，不能直接访问基类
### **继承**
*　成员访问权限
*　继承关系权限

### **继承中类作用域**
派生类的作用域嵌套在其基类中


### **虚析构函数**
基类通常都应该定义一个虚析构函数

### **类间关系**
**复合**-has a
类中包含另一种类
构造由内而外，析构由外而内
**委托**
类中包含一个指向其他类的指针
**继承**-is a

