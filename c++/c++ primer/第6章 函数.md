### **函数基础**
**函数定义**
* 返回类型
* 函数名字
* 形参列表：0个或多个，由逗号隔开
* 函数体
**函数调用**
使用调用运算符来调用函数
* 使用实参初始化函数对应的形参
* 将控制权转移给被调用函数
**函数返回**
* 返回return语句的值
* 将控制权从被调函数转回到主调函数

**形参与实参**
实参是形参的初始值，实参类型和数量必须与形参对应

**返回类型**
不能是数组或函数，但可以是指向数组或函数的指针
***
### **局部对象**
在形参和函数体内部定义的变量，仅在函数的作用域里可见
**作用域**：名字有作用域，名字的作用域是程序文本的一部分，名字在其中可见
**生命周期**：对象有生命周期，对象的声明周期是程序执行过程中该对象存在的一段时间

**自动对象**：只存在块执行期间的对象，普通局部变量对应的对象
**局部静态对象**：程序第一次经过对象定义语句时初始化，程序终止才销毁，即使函数执行结束该对象仍存在，生命周期贯穿函数调用及以后
***
### **函数声明**
可定义一次，声明多次，必须在使用前声明
返回类型+函数名+形参列表+；

### **参数传递**
**引用传递**
形参是引用类型，被绑定到对应的实参上
注：引用形参为我们一次返回多个结果提供了有效路径
**值传递**
将实参的值拷贝后赋予形参
注：指针形参虽然拷贝的是指针的值，拷贝后是不同的指针，但指向相同的地址，所以可以修改所指对象的值、

### **const形参和实参**
可以使用非常量初始化底层const，但不能用底层const初始化非常量

注：如果函数无需改变引用形参的值，最好将其声明为常量引用
普通引用不能接受const对象、字面值；常量引用可以接受非常量对象
***
### **数组形参**
1.不允许拷贝数组  所以无法使用值传递
2.使用数组（通常）会被转换为指针 所以为函数传递的数组实际上是指向数组首元素的指针
**形式**
三者等价
```
void print(const int*);
void print(int []);
void print(const int[10]);//实际传递的是指针，数组大小对函数调用没有影响
```
**数组长度**
* 使用标记指定数组长度 字符串空字符
* 传递指向数组首元素和尾后元素的指针
* 传递一个表示数组大小的形参
**传递多维数组**
```
void print(int a[][10]);
void print(int (*a)[10]);//指向含有10个整数的数组的指针

void print(int *a[10]);//10个指针构成的数组
```
***
### **main传参**
```
int main(int argc,char *argv[]){}
```
第二个参数 数组，元素是指向c风格字符串的指针（不是二维数组）。argv[0]指向程序名或空，后面依次是命令行提供的实参，最后一个元素为0
第一个参数 字符串的数量

### **含有可变形参的函数**
**实参类型相同**
使用initializer_list标准库类型
**实参类型不同**
可变参数模板
***
### **return**
终止正在执行的函数并将控制权返回到调用该函数的地方
注：不要返回局部变量的引用或指针，函数结束后内存空间会被释放

**引用返回左值**
甚至能为返回类型是非常量引用的函数的结果，可以位于赋值语句左侧
其他返回类型返回右值

**返回列表**
```
vector<int> process(){
	....
	return {0,1,2,3}
}
```
**返回数组指针**
* 类型别名
```
using arrT = int[10];//arrT是类型别名，表示含有10个整数的数组
arrT *func(int i); //func返回一个指向10个整数的数组的指针
```
* 不使用类型别名
```
int (*func(int i))[10];
```
* 使用尾置返回类型
跟在形参列表后并以->开头
```
auto func(int i)->int (*)[10];
```

***
### **函数重载**
如果同一作用域的几个函数名字相同但形参列表（数量或类型）不同，称为函数重载。编译器会根据实参类型判定调用哪个函数。
注：顶层const不算类型不同，底层const可以（指针或引用）
**const_cast**
常量与非常量的转换

### **默认实参**
在函数的多次调用时都给形参赋予了相同的值，这个值叫默认实参。
可以给多个形参定义默认值，但必须位于形参列表的末尾。
如果调用时想使用默认实参，只需要省略该实参就可，默认实参负责填补函数缺少i的尾部实参

### **内联函数**
在函数返回类型前加inline，在调用点内联的展开，减少函数运行开销
用于优化规模较小，流程直接，频繁调用的函数

### **constexpr函数**
能用于常量表达式的函数，编译器把constexpr函数替换成结果值，隐性定义为内联函数
* 函数返回类型和形参类型必须是字面值
* 函数体有且只有一条return

注：内联函数和constexpr函数可多次定义，通常定义在头文件中

### **assert预处理宏**
assert(expr)
对expr求值，如果表达式为假（0），assert输出信息并终止程序执行。表达式为真，则什么也不做、

### **函数匹配**
存在类型转换或默认实参时
1. 选定重载函数集
2. 考察实参（数量类型相同）
3. 寻找最佳匹配，没有最有匹配则报告二义性调用
**最佳匹配等级**
1.精确匹配（包括顶层const）
2.const转换实现的匹配
3.类型提升
4.算数类型转换
5.类类型转换

### **函数指针**
函数指针指向的是函数而非对象
```
int (*pf)(int a);//声明一个指向函数的指针
```
**使用**
```
pf=func;//pf指向名为func的函数
pf=&func;//等价，两种均可
```
**调用**
```
b1=pf(1);//调用func函数
b2=(*pf)(1);//等价的调用
```